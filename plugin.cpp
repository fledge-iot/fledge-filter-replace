/*
 * Fledge "asset" filter plugin.
 *
 * Copyright (c) 2021 Dianomic Systems Inc.
 *
 * Released under the Apache 2.0 Licence
 *
 * Author: Mark Riddoch
 */

#include <string>
#include <iostream>
#include <plugin_api.h>
#include <config_category.h>
#include <filter.h>
#include <reading_set.h>
#include <version.h>

#define FILTER_NAME "replace"

static const char *default_config = QUOTE({
		"plugin" : {
			"description" : "Replace reservered charecters in asset name and data point names",
                       	"type" : "string",
			"default" : FILTER_NAME,
			"readonly" : "true"
			},
		"enable": {
			"description": "A switch that can be used to enable or disable execution of the filter.",
			"displayName": "Enabled",
			"type": "boolean",
			"default": "false"
			},
		"replace" : {
			"description" : "Characters to replace. Simply a string of the characters to be replaced",
			"type" : "string",
			"default" : "*{}|[];?",
			"order" : "1",
			"displayName" : "Replace"
			},
		"replacement" : {
			"description" : "Character to use as a replacement.",
			"type" : "string",
			"default" : "_",
			"order" : "2",
			"displayName" : "With"
			}
		});

using namespace std;

/**
 * The Filter plugin interface
 */
extern "C" {

/**
 * The plugin information structure
 */
static PLUGIN_INFORMATION info = {
        FILTER_NAME,              // Name
        VERSION,                  // Version
        0,                        // Flags
        PLUGIN_TYPE_FILTER,       // Type
        "1.0.0",                  // Interface version
	default_config	          // Default plugin configuration
};

typedef struct
{
	FledgeFilter *handle;
	std::string	replace;
	char		replacement;
	std::string	configCatName;
} FILTER_INFO;

/**
 * Return the information about this plugin
 */
PLUGIN_INFORMATION *plugin_info()
{
	return &info;
}

/**
 * Initialise the plugin, called to get the plugin handle and setup the
 * output handle that will be passed to the output stream. The output stream
 * is merely a function pointer that is called with the output handle and
 * the new set of readings generated by the plugin.
 *     (*output)(outHandle, readings);
 *
 * @param config	The configuration category for the filter
 * @param outHandle	A handle that will be passed to the output stream
 * @param output	The output stream (function pointer) to which data is passed
 * @return		An opaque handle that is used in all subsequent calls to the plugin
 */
PLUGIN_HANDLE plugin_init(ConfigCategory* config,
			  OUTPUT_HANDLE *outHandle,
			  OUTPUT_STREAM output)
{
	FILTER_INFO *info = new FILTER_INFO;
	info->handle = new FledgeFilter(FILTER_NAME, *config, outHandle, output);
	FledgeFilter *filter = info->handle;
	info->configCatName = config->getName();
	
	// Handle filter configuration
	if (filter->getConfig().itemExists("replace"))
	{
		info->replace = filter->getConfig().getValue("replace");
	}
	else
	{
		Logger::getLogger()->error("No config provided for replace characters, cannot proceed");
		return NULL;
	}
	if (filter->getConfig().itemExists("replacement"))
	{
		string str = filter->getConfig().getValue("replacement");
		info->replacement = str[0];
	}
	else
	{
		Logger::getLogger()->error("No config provided for replacement character, cannot proceed");
		return NULL;
	}
	
	return (PLUGIN_HANDLE)info;
}

/**
 * Ingest a set of readings into the plugin for processing
 *
 * @param handle	The plugin handle returned from plugin_init
 * @param readingSet	The readings to process
 */
void plugin_ingest(PLUGIN_HANDLE *handle,
		   READINGSET *readingSet)
{
	FILTER_INFO *info = (FILTER_INFO *) handle;
	FledgeFilter* filter = info->handle;
	
	if (!filter->isEnabled())
	{
		// Current filter is not active: just pass the readings set
		filter->m_func(filter->m_data, readingSet);
		return;
	}


	// Just get all the readings in the readingset
	const vector<Reading *>& readings = readingSet->getAllReadings();
	
	// Iterate the readings
	for (vector<Reading *>::const_iterator elem = readings.begin();
						      elem != readings.end();
						      ++elem)
	{
		// Perform repalce in asset name
		string str = (*elem)->getAssetName();
		for (int i = 0; i < info->replace.length(); i++)
		{
			char c = info->replace[i];
			size_t pos;
			while ((pos = str.find_first_of(c)) != string::npos)
			{
				str[pos] = info->replacement;
			}
		}
		(*elem)->setAssetName(str);

		// Now do the data point names
		vector<Datapoint *> datapoints = (*elem)->getReadingData();
		for (auto dp = datapoints.begin(); dp != datapoints.end(); ++dp)
		{
			string str = (*dp)->getName();
			for (int i = 0; i < info->replace.length(); i++)
			{
				char c = info->replace[i];
				size_t pos;
				while ((pos = str.find_first_of(c)) != string::npos)
				{
					str[pos] = info->replacement;
				}
			}
			(*dp)->setName(str);
		}
	}

	filter->m_func(filter->m_data, readingSet);
}

/**
 * Plugin reconfiguration entry point
 *
 * @param	handle	The plugin handle
 * @param	newConfig	The new configuration data
 */
void plugin_reconfigure(PLUGIN_HANDLE *handle, const string& newConfig)
{
	FILTER_INFO *info = (FILTER_INFO *) handle;
	FledgeFilter* filter = info->handle;

	filter->setConfig(newConfig);

	if (filter->getConfig().itemExists("replace"))
	{
		info->replace = filter->getConfig().getValue("replace");
	}
	else
	{
		Logger::getLogger()->error("No config provided for replace characters, cannot proceed");
		return;
	}
	if (filter->getConfig().itemExists("replacement"))
	{
		string str = filter->getConfig().getValue("replacement");
		info->replacement = str[0];
	}
	else
	{
		Logger::getLogger()->error("No config provided for replacement character, cannot proceed");
		return;
	}
}

/**
 * Call the shutdown method in the plugin
 */
void plugin_shutdown(PLUGIN_HANDLE *handle)
{
	FILTER_INFO *info = (FILTER_INFO *) handle;
	delete info->handle;
	delete info;
}

// End of extern "C"
};

